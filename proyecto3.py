# -*- coding: utf-8 -*-
"""proyecto3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1robra7ZUWy9KtJ5kBk2RWZrJurET8RGG
"""

#Se guradan los nodos a utilizar
class Nodo:

    #se generan los vertices y los vecinos  donde v es un veciono y p es el peso 
    def __init__(self, i):
        self.id=i #es la id de los datos
        self.visitado=False
        self.nivel = -1
        self.m_vecinos =[]
        self.vecinos =[] #genera la lista de los vecinos
        self.padre = None #el sacestro
        self.distancia = float('inf')
         

    #Cargo la lista de vecinos que se genera
    

    def agregarVecino(self, v, p):
        if not v in self.vecinos:
            self.vecinos.append([v, p])
    
    def m_agregarVecino(self, v): # nos inica v el nodo y p el peso del nodo
        if not v in self.m_vecinos:
            self.m_vecinos.append(v)
    
class Grafo:
    def __init__(self):
        self.vertices ={} #key: id == key, lista identicadores del nodo que son sus vecinos
        
    #Genero la lista de nodos que tengo
    def agregaNodo(self, id):
        if id not in self.vertices:
            self.vertices[id]= Nodo(id)
       
    
    ##########################################################
    def agregarAristas(self, a, b, p): #contrulle la arista y les proporciona el peso p
        if a in self.vertices and b in self.vertices:
            
            self.vertices[a].agregarVecino(b, p) #cargamos los nodos con sus vecinos y pesos 
            self.vertices[b].agregarVecino(a, p)
        
            self.vertices[a].m_agregarVecino(b)
            self.vertices[b].m_agregarVecino(a)
    
    def bfs(self, r):# generamos un recorrido para saber que nodos esta concectados entre si
        storebfs = []
        if r in self.vertices:
            cola = [r]

            for v in range(0, len(self.vertices)):
                self.vertices[v].visitado = False

            self.vertices[r].visitado = True
            self.vertices[r].nivel = 0
            
            while( len(cola) > 0):
                act = cola[0]
                cola = cola[1:]

                for v in self.vertices[act].m_vecinos:
                    if self.vertices[v].visitado == False:
                        cola.append(v)
                        self.vertices[v].visitado = True
                        self.vertices[v].nivel = self.vertices[act].nivel + 1
                        storebfs.append((v, self.vertices[v].nivel))
        self.storeR = storebfs

        opciones_nodos = []
        for i in range(0, len(self.storeR)):
            for j in range(0, 2):
                if not self.storeR[i][j] in opciones_nodos:
                    opciones_nodos.append(self.storeR[i][j])

        print('Nodo dentro del grafo')
        print(opciones_nodos,'\n')

    def imprimirGrafica(self):
        for v in self.vertices:
            print(str(self.vertices[v].padre)+ ' ' + str(v) )

    #contruimos el camino de recorrido de uno nodo a a un nodo b
    def camino(self, a, b): # Realizo el recorrido de los nodos
        camino = []
        actual = b
        while actual != None:
            
            camino.insert(0, actual)
            
            actual =self.vertices[actual].padre
        return [camino, self.vertices[b].distancia]

    def minimo (self, lista): # Se hace la comparacion de las distancias o pesos para poder seleccionar la opcion mas correspondiente 
        if len(lista)>0:
            m=self.vertices[lista[0]].distancia
            v=lista[0]
            for e in lista:
                if m > self.vertices[e].distancia:
                    m = self.vertices[e].distancia
                    v=e
            return v  

    def dijkstra(self, a): realizar el recorrido 
        if  a in  self.vertices:
            self.vertices[a].distancia = 0 ##se coloca el nodo bacio
            actual = a
            noVisitados = [] #almacena los nodos no actualizados

            for v in self.vertices:
                self.vertices[v].visitado = False
                if v != a:
                    self.vertices[v].distancia = float('inf')
                self.vertices[v].padre = None
                noVisitados.append(v)
            
            while len(noVisitados)> 0:
                for vecino in self.vertices[actual].vecinos:
                    
                    if self.vertices[vecino[0]].visitado == False:
                        
                        if self.vertices[actual].distancia + vecino[1] <self.vertices[vecino[0]].distancia:
                            self.vertices[vecino[0]].distancia = self.vertices[actual].distancia + vecino[1]
                            self.vertices[vecino[0]].padre = actual
                
                self.vertices[actual].visitado =True
                noVisitados.remove(actual)

                actual = self.minimo(noVisitados)
        else:
            return False

    

    #############################################################

class Biblioteca:
    
    def __init__(self):
        self.listaAristas = []

    #Modelo Gm,n de malla. Crear m*n nodos. Para el nodo ni,j crear una arista con el nodo ni+1,j
    # y otra con el nodo ni,j+1, para i<m y j<n
    def grafoMalla(self, n, m, dirigido=False):
            
        """
        Genera grafo de malla
        :param m: número de columnas (> 1)
        :param n: número de filas (> 1)
        :param dirigido: el grafo es dirigido?
        :return: grafo generado
        """
        coordenada = []
        coordenadaH = []
        coordenadaV= []
        borrar = []
        vertical = []
        horizontal = [] 
        #Genero cooredenadas de tamaño m*n
        for i in range(0, m):
            for j in range(0, n):
                coordenada.append([i, j])

        #Inido el limite derecho de la maya 
        for fin in range(n-1, len(coordenada), n):
            borrar.append((fin, fin+1))
        
        #Generamos los aristas sobre el lado derecho
        for coordenadaH in range(0, len(coordenada)):
            vertical.append((coordenadaH, coordenadaH+1))
        #eliminamos aritas que no pertenecen a la maya                   
        vetical=list(set(vertical)-set(borrar))
        #generamos la aritas verticales 
        for i in range(0, len(coordenada)):    
            coordenadaV.append((i, i+n))

        #Selecciono las aristas que seran generas para el grafo
        longitud = len(coordenadaV)-n
        s=0
        while s < len(coordenadaV):
            if s == longitud:
                s = len(coordenadaV)
            else:
                horizontal.append(coordenadaV[s])
                s+=1
        self.listaAristas = horizontal + vetical
        
            
    #Modelo Gn,m de Erdös y Rényi. Crear n nodos y elegir uniformemente al azar m distintos pares de distintos vértices.
    def grafoErdosRenyi(self, n, m, dirigido=False, auto=False):
        import random as rd
        """
        Genera grafo aleatorio con el modelo Erdos-Renyi
        :param n: número de nodos (> 0)
        :param m: número de aristas (>= n-1)
        :param dirigido: el grafo es dirigido?
        :param auto: permitir auto-ciclos?
        :return: grafo generado
        """
        aristarepe = []
        s=0
        
        while s < m: #proporciono el la cantidad de aritrias que se puede generar 
            #Selecciono dos nodos al azar 
            u=rd.randint(1, n) 
            v=rd.randint(1, n)
            #Si estan repetidos realizo otro intento
            if u == v:
                s-=1
            elif u != v:
                nod2= u,v
            if nod2 in aristarepe:
                s-=1
            else:
                aristarepe.append((nod2))
            s+=1
        self.listaAristas = aristarepe
        
    #Modelo Gn,p de Gilbert. Crear n nodos y poner una arista entre cada par independiente y uniformemente con probabilidad p.
    def grafoGilbert(self, n, p, dirigido=False, auto=False):
        import random as rd
        """
        Genera grafo aleatorio con el modelo Gilbert
        :param n: número de nodos (> 0)
        :param p: probabilidad de crear una arista (0, 1)
        :param dirigido: el grafo es dirigido?
        :param auto: permitir auto-ciclos?
        :return: grafo generado"""
    
        l=list(range(n)) #se genera una lista de nodos

        #Se lee el los nodos y se realiza un cilco for
        l = ([(l,j) 
            for l in range(n)   
                for j in range(l)   
                    if rd.random() < p]) #toma la decisicon mediante un promedio si se realiza union o no mediate un true o False
        
        self.listaAristas = l

    #Modelo Gn,r geográfico simple. Colocar n nodos en un rectángulo unitario con coordenadas 
    #uniformes (o normales) y colocar una arista entre cada par que queda en distancia r o menor.
    def grafoGeografico(self, n, r, x, y, dirigido=False, auto=False):
        import random as rd
        """
        Genera grafo aleatorio con el modelo geográfico simple
        :param n: número de nodos (> 0)
        :param r: distancia máxima para crear un nodo (0, 1)
        :param dirigido: el grafo es dirigido?
        :param auto: permitir auto-ciclos?
        :return: grafo generado
        """
        coor = []
        numNodoCoor = []
        for i in range(x):
            for j in range(y):
                coor.append((i, j))

        # Genera el numero numero del nodos y su cooredenada 
        for i in range(0, len(coor)-1): 
            j = i, coor[i]
            numNodoCoor.append(j)

        nodoGPS = [] # coordenadas en el cuadrado (m*m)-1
        listaNodo =[]
        #Genero lista de nodos posibles 
        for i in range(n-1):
            listaNodo.append(i)

        #genero al azar nodos dentro del limiete de mis coordenadas 
        totalNodos =rd.randint(1, n-1)
        s=0
        while s < totalNodos: #selecciono al azar el nodo
                
            nodo = rd.choice(listaNodo)
            tomoNodo = listaNodo.index(nodo)
            nodoGPS.append(nodo)

            del listaNodo[tomoNodo] #elimino para no tener repetidos 

            s+=1

        listaNodoRadio =[]

        #Asigno el nodos seleccionado con su coordenada
        for i in range(0, len(nodoGPS)):
            j=numNodoCoor[nodoGPS[i]]
            listaNodoRadio.append(j)

        s=0
        nodoOrigen = []
        nodoMapa = []
        while s < totalNodos:
            
            #tomo un nodo de listaNodoRadio y lo agrego a nodoOtogen
            nodoOrigen.append(listaNodoRadio[0])
            #Elimino el nodo listaNodoRadio que tome
            del listaNodoRadio[0]
            #se utilizara el metodo de puntos dnetro de un circulo donde nodoOrigen es el nodo del centro 
            # y listaNodoRadio son los nodos cercanos a ese nodo

            for i in range(0, len(listaNodoRadio)):
                rN = ((listaNodoRadio[i][1][0]-nodoOrigen[s][1][0])**2) + ((listaNodoRadio[i][1][1]-nodoOrigen[s][1][1])**2)
                if rN <= r:
                    nodoMapa.append((nodoOrigen[s][0], listaNodoRadio[i][0]))         
            s+=1

        self.listaAristas = nodoMapa

    #Variante del modelo Gn,d Barabási-Albert. Colocar n nodos uno por uno, asignando a cada uno d aristas a vértices distintos de tal manera
    # que la probabilidad de que el vértice nuevo se conecte a un vértice existente v es proporcional a la cantidad de aristas que v tiene 
    # actualmente - los primeros d vértices se conecta todos a todos.
    def grafoBarabasiAlbert(self, n, d, dirigido=False, auto=False):
        import random as rd
        """
        Genera grafo aleatorio con el modelo Barabasi-Albert
        :param n: número de nodos (> 0)
        :param d: grado máximo esperado por cada nodo (> 1)
        :param dirigido: el grafo es dirigido?
        :param auto: permitir auto-ciclos?
        :return: grafo generado
        """
        l= n
        m=range(n)

        listaNodos = []
        for i in range(0, len(m)):
            listaNodos.append(i)

        nodoUtiles = []
        listaTemporal = []
        nodoAceptado = []
        nodoRevicion = []
        nodoSeleccionados = []
        s=0
        x=0
        #contrullo tomo cada nodo de la lista
        while s < l: 
            s1 = 0
            for i in listaNodos:
                nodoUtiles.append(i)
            del nodoUtiles[0]

            while s1 < d:

                if s != 0 and s1 == 0:
                    for i  in range(0, len(listaTemporal)):
                        j = listaTemporal[i][1]
                        if j == s:
                            s1+=1
                    
                #reglas de promedio para nueva arista
                if s1 != 0:
                    p = 1-(s1/d)
                else:
                    p = 1
                    c = 0

                # Creo la primera aista
                # Proporciono una probavilidad para unirlos al siguiente nodo o no
                if rd.random() < p: # Si es True lo gurdo
                    if s != nodoUtiles[c]:
                        nodoCandidato = s, nodoUtiles[c] #genero una arista
                        listaTemporal.append(nodoCandidato) #la cargo a una pila
                        nodoSeleccionados.append(s)
                        nodoSeleccionados.append(nodoUtiles[c])
                        del nodoUtiles[c] #elimino 
                    
                else:
                    s1-=1
                    c+=1

                # pregunnro si ya lei todos los nodos del grafo
                if c == len(nodoUtiles):
                    c = 0

                s1+=1
            nodoUtiles = [ ]
            print
            s+=1
        
        self.listaAristas = listaTemporal

    #Modelo Gn Dorogovtsev-Mendes. Crear 3 nodos y 3 aristas formando un triángulo. Después, para cada nodo adicional,
    # se selecciona una arista al azar y se crean aristas entre el nodo nuevo y los extremos de la arista seleccionada. 
    def grafoDorogovtsevMendes(self, n, dirigido=False):
        import random as rd
        """
        Genera grafo aleatorio con el modelo Barabasi-Albert
        :param n: número de nodos (≥ 3)
        :param dirigido: el grafo es dirigido?
        :return: grafo generado
        """
        
        listaNodo = []
        candidatosNodo = []
        trinagulo = []

        for i in range(n):
            listaNodo.append(i)
        
        # Genero un base para conectrar los otros triagulos 
        s = 0
        while s < 3:
        
            nodo = rd.choice(listaNodo) #selecciono un nodo al hazar
            tomoNodo = listaNodo.index(nodo)
            candidatosNodo.append(nodo) #lista candidato

            del listaNodo[tomoNodo] #Elimino el nodo tomado

            s+=1
        # Construyo el primer triangulos
        trinagulo.append((candidatosNodo[0], candidatosNodo[1]))
        trinagulo.append((candidatosNodo[1], candidatosNodo[2]))
        trinagulo.append((candidatosNodo[0], candidatosNodo[2]))
        #Se lecciono un nodo de los disponibles y lo uno con dos nodos de mi lista de candidatos
        # se elmina el nodo tomado y se continua asta finalizar todos los nodos
        s1 = 0
        while s1 < len(trinagulo):
            if len(listaNodo) == 0:
                s1 = len(trinagulo) #Rompe el ciclo
            else:

                nodoB = rd.choice(listaNodo) #elijo un nodo
                nodoT = listaNodo.index(nodoB) #lo convierto en index para eliminar
                
                arista_Azar = rd.choice(trinagulo)
                
                    
                trinagulo.append((nodoB, arista_Azar[0]))
                trinagulo.append((nodoB, arista_Azar[1]))

                del listaNodo[nodoT]
                
            
        
        self.listaAristas = trinagulo
        print(self.listaAristas)

class Csv:
    
    def tablaSimple(self, listaAristas): ## Se adapta una tabla para cargar los datoa a gephi donde nos muestre el grafo entero
        import pandas as pd
        datos_Csv = []
        datos_Csv_Completos = []

        for i in listaAristas:
            datos_Csv.append((i, 'No dirigida'))

        for i in range(0, len(datos_Csv)):
            datos_Csv_Completos.append((datos_Csv[i][0][0], datos_Csv[i][0][1], datos_Csv[i][0][2], datos_Csv[i][1]))
        
        self.df = pd.DataFrame(datos_Csv_Completos)

        self.df.columns = [ 'Target', 'Source', 'Weight', 'tipo']
    
    def tablaRecorrida(self, listaAristasPeso, caminos_re, listaAristas): #Se crea una talba para distiguir el camino con menor peso 
        import pandas as pd
        recorrido = []
        lista_Csv = []
        lista_Csv_Mixto = []

        #convierto los nodos del recorrido en aristas
        for i in range(0, len(caminos_re)-1):
            recorrido.append((caminos_re[i], caminos_re[i+1])) 

        #coloco la mejor ruta solo como dirigijo para resaltar 
        s= 0
        while s < len(listaAristas) :
            for i in range(0, len(recorrido)):
                if listaAristas[s] == recorrido[i]:
                    lista_Csv.append((listaAristasPeso[s], 'Dirigida'))
                    s+=1
                elif listaAristas[s] != recorrido[i] and i == len(recorrido)-1:
                    lista_Csv.append((listaAristasPeso[s], 'No dirigida'))


            s+=1



        for i in range(0, len(lista_Csv)):
            lista_Csv_Mixto.append((lista_Csv[i][0][0], lista_Csv[i][0][1], lista_Csv[i][0][2], lista_Csv[i][1]))
                
        self.dfe = pd.DataFrame(lista_Csv_Mixto)
        self.dfe.columns = ['Target', 'Source', 'Weight', 'tipo'] ### Se adaptan los nombres para generar las tablas y poder carharlo en gephi

    def tabla_id(self, n, caminos_re):
        import pandas as pd
        self.lista_Id = []
        self.recorrido_Costo = []

        for i in range(n):
            self.lista_Id.append((i, i))
            
        self.dfw = pd.DataFrame(self.lista_Id)
        self.dfw.columns = [ 'Id', 'Label']


        s = 0
        while s < n+1:
            for j in range(0, len(caminos_re)):
                if s == caminos_re[j]:
                    self.recorrido_Costo.append((s, caminos_re[j]))
                    s+=1
                
                elif s != caminos_re[j] and j == len(caminos_re)-1:

                    self.recorrido_Costo.append((s, ' '))
            s+=1

        self.dfS = pd.DataFrame(self.recorrido_Costo)
        self.dfS.columns = [ 'Id', 'Label']
        

    def archivos(self, opcion, listaAristasPeso, n, caminos_re, listaAristas): #Genero archivo para gephi
        import pandas as pd
        self.c = Csv

        self.listaAristasPeso = listaAristasPeso
        self.caminos_re = caminos_re

        self.c.tablaSimple(self, self.listaAristasPeso)
        self.c.tabla_id(self, n, self.caminos_re)
        self.c.tablaRecorrida(self, listaAristasPeso, caminos_re, listaAristas)
        
        print('Para cargar los datos a gephi se generan 4 archivos si solo cuenta con el nombre  y un con el nombre más _id ',
              'se genera un grafo sin ningun analisis de pesos, para los archivos que generan en nombre__Id_Recorrido y nombre_Reco ', 
              'nos dara un grafo donde podemos ver solo los nodos que estan denro del recorrido')
        print('\n ejemplo: malla.csv y malla_Id.csv se formar los grafos completos sin ninguna distincion ',
              'malla_Id_Recorrido.csv y malla_Reco podemos cargar un grafo donde se destacan los grafo que estan dentro de los recorridos ')

        if opcion == 1:
            self.df.to_csv('malla.csv', index=False)
            self.dfw.to_csv('malla_Id.csv', index=False)
            self.dfS.to_csv('malla_Id_Recorrido.csv', index=False)
            self.dfe.to_csv('malla_Reco.csv', index=False)

        elif opcion == 2:
            self.df.to_csv('ErdosRenyi.csv', index=False)
            self.dfw.to_csv('ErdosRenyi_Id.csv', index=False)
            self.dfS.to_csv('ErdosRenyi_Id_Recorrido.csv', index=False)
            self.dfe.to_csv('ErdosRenyi_Reco.csv', index=False)

        elif opcion == 3:
            self.df.to_csv('Gilbert.csv', index=False)
            self.dfw.to_csv('Gilbert_Id.csv', index=False)
            self.dfS.to_csv('Gilbert_Id_Recorrido.csv', index=False)
            self.dfe.to_csv('Gilbert_Reco.csv', index=False)

        elif opcion == 4:
            self.df.to_csv('Geográfico.csv', index=False)
            self.dfw.to_csv('Geográfico_Id.csv', index=False)
            self.dfS.to_csv('Geográfico_Id_Recorrido.csv', index=False)
            self.dfe.to_csv('Geográfico_Reco.csv', index=False)

        elif opcion == 5:
            self.df.to_csv('BarabasiAlbert.csv', index=False)
            self.dfw.to_csv('BarabasiAlbert_Id.csv', index=False)
            self.dfS.to_csv('BarabasiAlbert_Id_Recorrido.csv', index=False)
            self.dfe.to_csv('BarabasiAlbert_Reco.csv', index=False)

        elif opcion == 6:
            self.df.to_csv('trinagulo.csv', index=False)
            self.dfw.to_csv('trinagulo_Id.csv', index=False)
            self.dfS.to_csv('trinagulo_Id_Recorrido.csv', index=False)
            self.dfe.to_csv('trinagulo_Reco.csv', index=False)



class NodosAristas:
    def __init__(self):
        self.b = Biblioteca()
        self.g = Grafo()       
        self.peso = []
        self.listaDj = []
          
    def nodoID(self, n, listaAristas):
        import random as rd
        
        #Se prorciona la lista de nodo a la clase nodo
        self.p = n
        self.listaAristas = listaAristas
        for v in range(self.p):
            self.g.agregaNodo(v)

        
        listaAristasL = []
        
        self.listaAristasS  = self.listaAristas
        for i in self.listaAristasS:
            for j in i:
                listaAristasL.append(j)
        
     

#_____________________________________DJ_______________________________________

        listaLipia = [] #Elimino los parentecis de la lista 
        self.caminos_re = []

        self.grafo_Peso = []

        for i in self.listaAristas:
            for j in i:
                listaLipia.append(j)

        for i in range(0, len(listaLipia)-1, 2): #Recorro la lista de dos en dos y agrego un nuevo valor que sera el peso 
            p = rd.randint(80, 100)
            self.peso.append((listaLipia[i], listaLipia[i+1], p))

        print(self.peso)
        for i in range(0, len(self.peso)): #Leo la lista con pesos y elimino parenteisis para poder procesarlo
            for j in range(0, 3):    
                self.listaDj.append(self.peso[i][j]) 
       
        for i in range(0, len(self.listaDj)-1, 3): #Agrego los valores para definir la arita y la distancia entre ellos
            self.g.agregarAristas( self.listaDj[i],  self.listaDj[i+1],  self.listaDj[i+2])
            self.grafo_Peso.append(( self.listaDj[i],  self.listaDj[i+1],  self.listaDj[i+2]))
        
        
        nodos_Aceptados = []
        for v in self.g.vertices:
            if self.g.vertices[v].m_vecinos != []:
                nodos_Aceptados.append(v) 
        print('\n Lista de nodos que pueden ser utlizados')
        print(nodos_Aceptados)
        inicio = int(input("\n Ingrese el nodo de inicio \n"))

        self.g.bfs(inicio)

       
        final = int(input("\n Ingrese el nodo final \n"))
        self.g.dijkstra(inicio)
        self.lista_Recorrido = self.g.camino(inicio,final)
        print('Inicia en el nodo: ', inicio, 'hasta al nodo ', final )
        print('Nodos recorridos: ' + str(self.lista_Recorrido[0]), 'costo total: ',  str(self.lista_Recorrido[1])) #entrega el camino de cada nodo 

        for i in range(0, len(self.lista_Recorrido[0])):
            self.caminos_re.append(self.lista_Recorrido[0][i])

        
#_____________________________________DJ_______________________________________   

class Menu:
    def __init__(self): 
        import random as rd
        self.b = Biblioteca()
        self.g = Grafo()
        self.c = Csv()
        self.nod = NodosAristas()   
    
    
    def imprimircsv(self, opcion, grafo_Peso, n, caminos_re, listaAristas):
        generaArchivo = int(input("Generar un archivo CSV \n 1. Si \n 2. No \n"))
        if generaArchivo == 1:
            self.c.archivos(opcion, grafo_Peso,n, caminos_re, listaAristas)
        else:
            print('No hay CSV \n ')

    def opcionesMenu(self, opcion): 
        import random as rd
        #////////////////////////////////////////////////////////////////////////7  
        #se obteiene n nodos al azar
        self.n =rd.randint(0, 500) ########## se indica los nodos al azzar
        while opcion != 0:
            if opcion == 1:
                m= rd.randint(0, 500) #### se indica los nodos m para la malla
                n = self.n*m
                print('Graficar la malla')
                self.b.grafoMalla(self.n, m) 
                
                
                self.nod.nodoID(n, self.b.listaAristas)
                Menu.imprimircsv(self, opcion, self.nod.grafo_Peso, n, self.nod.caminos_re, self.b.listaAristas)
                
                

            elif opcion == 2:
                m=rd.randint(3, n) #### indica el número de aristas para Erdos Renyi 
                print('Graficar la Erdos Renyi')
                self.b.grafoErdosRenyi(self.n, m)
                self.nod.nodoID(self.n, self.b.listaAristas)
                Menu.imprimircsv(self, opcion, self.nod.grafo_Peso, self.n, self.nod.caminos_re, self.b.listaAristas)
                

            elif opcion == 3:
                print('Graficar la Gilbert')
                #Se proporciona un promedio 
                p = 0.25
                self.b.grafoGilbert(self.n, p)
                self.nod.nodoID(self.n, self.b.listaAristas)
                Menu.imprimircsv(self, opcion, self.nod.grafo_Peso, self.n, self.nod.caminos_re, self.b.listaAristas)
                

            elif opcion == 4:
                print('Graficar la Geografico')
                r = int(input("Indique un radio "))
                x = int(input("Indique una longitud x"))
                y = int(input("Indique una altura y"))
                self.b.grafoGeografico(self.n, r, x, y) # es importante generar un cuadrado x y y confome al tamaño de n
                print(self.b.listaAristas)
                self.nod.nodoID(self.n, self.b.listaAristas)
                Menu.imprimircsv(self, opcion, self.nod.grafo_Peso, self.n, self.nod.caminos_re, self.b.listaAristas)
                
            elif opcion == 5:
                print('Graficar la BarabasiAlbert')
                d = rd.randint(1, self.n-1)
                self.b.grafoBarabasiAlbert(self.n, d)
                self.nod.nodoID(self.n, self.b.listaAristas)
                Menu.imprimircsv(self, opcion, self.nod.grafo_Peso, self.n, self.nod.caminos_re, self.b.listaAristas)
                
            elif opcion == 6:
                print('Graficar la Dorogovtsev Mendes')
                self.b.grafoDorogovtsevMendes(self.n)
                
                self.nod.nodoID(self.n, self.b.listaAristas)
                Menu.imprimircsv(self, opcion, self.nod.grafo_Peso, self.n, self.nod.caminos_re, self.b.listaAristas)
                
            elif opcion == 0:
                print('Gracias')
            else:
                print('esa opcion no esta en el menú')
            
            
            opcion = int(input("Menú Principal: \n 1. Graficar la malla \n 2. Graficar la Erdos Renyi \n 3. Graficar la Gilbert \n 4. Graficar la Geografico \n 5. Graficar la BarabasiAlbert \n 6. Graficar la Dorogovtsev Mendes \n 0. Salir \n"))
                        
class Main:
    me = Menu()
    
    opcion = int(input("Menú Principal: \n 1. Graficar la malla \n 2. Graficar la Erdos Renyi \n 3. Graficar la Gilbert \n 4. Graficar la Geografico \n 5. Graficar la BarabasiAlbert \n 6. Graficar la Dorogovtsev Mendes \n 0. Salir \n"))
    if opcion == 0:
        print('Gracias')
    me.opcionesMenu(opcion)
    

Main()